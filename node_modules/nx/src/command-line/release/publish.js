"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.releasePublish = exports.releasePublishCLIHandler = void 0;
const nx_json_1 = require("../../config/nx-json");
const devkit_exports_1 = require("../../devkit-exports");
const project_graph_1 = require("../../project-graph/project-graph");
const run_command_1 = require("../../tasks-runner/run-command");
const command_line_utils_1 = require("../../utils/command-line-utils");
const logger_1 = require("../../utils/logger");
const graph_1 = require("../graph/graph");
const config_1 = require("./config/config");
const filter_release_groups_1 = require("./config/filter-release-groups");
const releasePublishCLIHandler = (args) => releasePublish(args);
exports.releasePublishCLIHandler = releasePublishCLIHandler;
/**
 * NOTE: This function is also exported for programmatic usage and forms part of the public API
 * of Nx. We intentionally do not wrap the implementation with handleErrors because users need
 * to have control over their own error handling when using the API.
 */
async function releasePublish(args) {
    /**
     * When used via the CLI, the args object will contain a __overrides_unparsed__ property that is
     * important for invoking the relevant executor behind the scenes.
     *
     * We intentionally do not include that in the function signature, however, so as not to cause
     * confusing errors for programmatic consumers of this function.
     */
    const _args = args;
    const projectGraph = await (0, project_graph_1.createProjectGraphAsync)({ exitOnError: true });
    const nxJson = (0, nx_json_1.readNxJson)();
    if (_args.verbose) {
        process.env.NX_VERBOSE_LOGGING = 'true';
    }
    // Apply default configuration to any optional user configuration
    const { error: configError, nxReleaseConfig } = await (0, config_1.createNxReleaseConfig)(projectGraph, nxJson.release, 'nx-release-publish');
    if (configError) {
        return await (0, config_1.handleNxReleaseConfigError)(configError);
    }
    const { error: filterError, releaseGroups, releaseGroupToFilteredProjects, } = (0, filter_release_groups_1.filterReleaseGroups)(projectGraph, nxReleaseConfig, _args.projects, _args.groups);
    if (filterError) {
        devkit_exports_1.output.error(filterError);
        process.exit(1);
    }
    if (args.projects?.length) {
        /**
         * Run publishing for all remaining release groups and filtered projects within them
         */
        for (const releaseGroup of releaseGroups) {
            await runPublishOnProjects(_args, projectGraph, nxJson, Array.from(releaseGroupToFilteredProjects.get(releaseGroup)));
        }
        return process.exit(0);
    }
    /**
     * Run publishing for all remaining release groups
     */
    for (const releaseGroup of releaseGroups) {
        await runPublishOnProjects(_args, projectGraph, nxJson, releaseGroup.projects);
    }
    if (_args.dryRun) {
        logger_1.logger.warn(`\nNOTE: The "dryRun" flag means no projects were actually published.`);
    }
    process.exit(0);
}
exports.releasePublish = releasePublish;
async function runPublishOnProjects(args, projectGraph, nxJson, projectNames) {
    const projectsToRun = projectNames.map((projectName) => projectGraph.nodes[projectName]);
    const overrides = (0, command_line_utils_1.createOverrides)(args.__overrides_unparsed__);
    if (args.registry) {
        overrides.registry = args.registry;
    }
    if (args.tag) {
        overrides.tag = args.tag;
    }
    if (args.otp) {
        overrides.otp = args.otp;
    }
    if (args.dryRun) {
        overrides.dryRun = args.dryRun;
        /**
         * Ensure the env var is set too, so that any and all publish executors triggered
         * indirectly via dependsOn can also pick up on the fact that this is a dry run.
         */
        process.env.NX_DRY_RUN = 'true';
    }
    if (args.verbose) {
        process.env.NX_VERBOSE_LOGGING = 'true';
    }
    const targets = ['nx-release-publish'];
    if (args.graph) {
        const file = (0, command_line_utils_1.readGraphFileFromGraphArg)(args);
        const projectNames = projectsToRun.map((t) => t.name);
        return await (0, graph_1.generateGraph)({
            watch: false,
            all: false,
            open: true,
            view: 'tasks',
            targets,
            projects: projectNames,
            file,
        }, projectNames);
    }
    else {
        /**
         * Run the relevant nx-release-publish executor on each of the selected projects.
         */
        const status = await (0, run_command_1.runCommand)(projectsToRun, projectGraph, { nxJson }, {
            targets,
            outputStyle: 'static',
            ...args,
        }, overrides, null, {}, { excludeTaskDependencies: false, loadDotEnvFiles: true });
        if (status !== 0) {
            // fix for https://github.com/nrwl/nx/issues/1666
            if (process.stdin['unref'])
                process.stdin.unref();
            process.exit(status);
        }
    }
}
