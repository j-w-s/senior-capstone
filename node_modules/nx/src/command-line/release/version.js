"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.releaseVersion = exports.releaseVersionCLIHandler = exports.deriveNewSemverVersion = void 0;
const chalk = require("chalk");
const node_fs_1 = require("node:fs");
const node_path_1 = require("node:path");
const nx_json_1 = require("../../config/nx-json");
const devkit_exports_1 = require("../../devkit-exports");
const tree_1 = require("../../generators/tree");
const project_graph_1 = require("../../project-graph/project-graph");
const params_1 = require("../../utils/params");
const generate_1 = require("../generate/generate");
const generator_utils_1 = require("../generate/generator-utils");
const config_1 = require("./config/config");
const filter_release_groups_1 = require("./config/filter-release-groups");
const git_1 = require("./utils/git");
const print_changes_1 = require("./utils/print-changes");
const shared_1 = require("./utils/shared");
// Reexport some utils for use in plugin release-version generator implementations
var semver_1 = require("./utils/semver");
Object.defineProperty(exports, "deriveNewSemverVersion", { enumerable: true, get: function () { return semver_1.deriveNewSemverVersion; } });
const releaseVersionCLIHandler = (args) => (0, params_1.handleErrors)(args.verbose, () => releaseVersion(args));
exports.releaseVersionCLIHandler = releaseVersionCLIHandler;
/**
 * NOTE: This function is also exported for programmatic usage and forms part of the public API
 * of Nx. We intentionally do not wrap the implementation with handleErrors because users need
 * to have control over their own error handling when using the API.
 */
async function releaseVersion(args) {
    const projectGraph = await (0, project_graph_1.createProjectGraphAsync)({ exitOnError: true });
    const { projects } = (0, project_graph_1.readProjectsConfigurationFromProjectGraph)(projectGraph);
    const nxJson = (0, nx_json_1.readNxJson)();
    if (args.verbose) {
        process.env.NX_VERBOSE_LOGGING = 'true';
    }
    // Apply default configuration to any optional user configuration
    const { error: configError, nxReleaseConfig } = await (0, config_1.createNxReleaseConfig)(projectGraph, nxJson.release, 'nx-release-publish');
    if (configError) {
        return await (0, config_1.handleNxReleaseConfigError)(configError);
    }
    const { error: filterError, releaseGroups, releaseGroupToFilteredProjects, } = (0, filter_release_groups_1.filterReleaseGroups)(projectGraph, nxReleaseConfig, args.projects, args.groups);
    if (filterError) {
        devkit_exports_1.output.error(filterError);
        process.exit(1);
    }
    const tree = new tree_1.FsTree(devkit_exports_1.workspaceRoot, args.verbose);
    const versionData = {};
    const userCommitMessage = args.gitCommitMessage || nxReleaseConfig.version.git.commitMessage;
    if (args.projects?.length) {
        /**
         * Run versioning for all remaining release groups and filtered projects within them
         */
        for (const releaseGroup of releaseGroups) {
            const releaseGroupName = releaseGroup.name;
            // Resolve the generator data for the current release group
            const generatorData = resolveGeneratorData({
                ...extractGeneratorCollectionAndName(`release-group "${releaseGroupName}"`, releaseGroup.version.generator),
                configGeneratorOptions: releaseGroup.version.generatorOptions,
                projects,
            });
            const releaseGroupProjectNames = Array.from(releaseGroupToFilteredProjects.get(releaseGroup));
            await runVersionOnProjects(projectGraph, nxJson, args, tree, generatorData, releaseGroupProjectNames, releaseGroup, versionData);
        }
        // Resolve any git tags as early as possible so that we can hard error in case of any duplicates before reaching the actual git command
        const gitTagValues = args.gitTag ?? nxReleaseConfig.version.git.tag
            ? (0, shared_1.createGitTagValues)(releaseGroups, releaseGroupToFilteredProjects, versionData)
            : [];
        (0, shared_1.handleDuplicateGitTags)(gitTagValues);
        printAndFlushChanges(tree, !!args.dryRun);
        if (args.gitCommit ?? nxReleaseConfig.version.git.commit) {
            await (0, shared_1.commitChanges)(tree.listChanges().map((f) => f.path), !!args.dryRun, !!args.verbose, (0, shared_1.createCommitMessageValues)(releaseGroups, releaseGroupToFilteredProjects, versionData, userCommitMessage), args.gitCommitArgs || nxReleaseConfig.version.git.commitArgs);
        }
        if (args.gitTag ?? nxReleaseConfig.version.git.tag) {
            devkit_exports_1.output.logSingleLine(`Tagging commit with git`);
            for (const tag of gitTagValues) {
                await (0, git_1.gitTag)({
                    tag,
                    message: args.gitTagMessage || nxReleaseConfig.version.git.tagMessage,
                    additionalArgs: args.gitTagArgs || nxReleaseConfig.version.git.tagArgs,
                    dryRun: args.dryRun,
                    verbose: args.verbose,
                });
            }
        }
        if (args.dryRun) {
            devkit_exports_1.logger.warn(`\nNOTE: The "dryRun" flag means no changes were made.`);
        }
        return {
            // An overall workspace version cannot be relevant when filtering to independent projects
            workspaceVersion: undefined,
            projectsVersionData: versionData,
        };
    }
    /**
     * Run versioning for all remaining release groups
     */
    for (const releaseGroup of releaseGroups) {
        const releaseGroupName = releaseGroup.name;
        // Resolve the generator data for the current release group
        const generatorData = resolveGeneratorData({
            ...extractGeneratorCollectionAndName(`release-group "${releaseGroupName}"`, releaseGroup.version.generator),
            configGeneratorOptions: releaseGroup.version.generatorOptions,
            projects,
        });
        await runVersionOnProjects(projectGraph, nxJson, args, tree, generatorData, releaseGroup.projects, releaseGroup, versionData);
    }
    // Resolve any git tags as early as possible so that we can hard error in case of any duplicates before reaching the actual git command
    const gitTagValues = args.gitTag ?? nxReleaseConfig.version.git.tag
        ? (0, shared_1.createGitTagValues)(releaseGroups, releaseGroupToFilteredProjects, versionData)
        : [];
    (0, shared_1.handleDuplicateGitTags)(gitTagValues);
    printAndFlushChanges(tree, !!args.dryRun);
    // Only applicable when there is a single release group with a fixed relationship
    let workspaceVersion = undefined;
    if (releaseGroups.length === 1) {
        const releaseGroup = releaseGroups[0];
        if (releaseGroup.projectsRelationship === 'fixed') {
            const releaseGroupProjectNames = Array.from(releaseGroupToFilteredProjects.get(releaseGroup));
            workspaceVersion = versionData[releaseGroupProjectNames[0]].newVersion; // all projects have the same version so we can just grab the first
        }
    }
    const changedFiles = tree.listChanges().map((f) => f.path);
    // No further actions are necessary in this scenario (e.g. if conventional commits detected no changes)
    if (!changedFiles.length) {
        return {
            workspaceVersion,
            projectsVersionData: versionData,
        };
    }
    if (args.stageChanges) {
        devkit_exports_1.output.logSingleLine(`Staging changed files with git because --stage-changes was set`);
        await (0, git_1.gitAdd)({
            changedFiles,
            dryRun: args.dryRun,
            verbose: args.verbose,
        });
    }
    if (args.gitCommit ?? nxReleaseConfig.version.git.commit) {
        await (0, shared_1.commitChanges)(changedFiles, !!args.dryRun, !!args.verbose, (0, shared_1.createCommitMessageValues)(releaseGroups, releaseGroupToFilteredProjects, versionData, userCommitMessage), args.gitCommitArgs || nxReleaseConfig.version.git.commitArgs);
    }
    if (args.gitTag ?? nxReleaseConfig.version.git.tag) {
        devkit_exports_1.output.logSingleLine(`Tagging commit with git`);
        for (const tag of gitTagValues) {
            await (0, git_1.gitTag)({
                tag,
                message: args.gitTagMessage || nxReleaseConfig.version.git.tagMessage,
                additionalArgs: args.gitTagArgs || nxReleaseConfig.version.git.tagArgs,
                dryRun: args.dryRun,
                verbose: args.verbose,
            });
        }
    }
    if (args.dryRun) {
        devkit_exports_1.logger.warn(`\nNOTE: The "dryRun" flag means no changes were made.`);
    }
    return {
        workspaceVersion,
        projectsVersionData: versionData,
    };
}
exports.releaseVersion = releaseVersion;
function appendVersionData(existingVersionData, newVersionData) {
    // Mutate the existing version data
    for (const [key, value] of Object.entries(newVersionData)) {
        if (existingVersionData[key]) {
            throw new Error(`Version data key "${key}" already exists in version data. This is likely a bug.`);
        }
        existingVersionData[key] = value;
    }
    return existingVersionData;
}
async function runVersionOnProjects(projectGraph, nxJson, args, tree, generatorData, projectNames, releaseGroup, versionData) {
    const generatorOptions = {
        // Always ensure a string to avoid generator schema validation errors
        specifier: args.specifier ?? '',
        preid: args.preid ?? '',
        ...generatorData.configGeneratorOptions,
        // The following are not overridable by user config
        projects: projectNames.map((p) => projectGraph.nodes[p]),
        projectGraph,
        releaseGroup,
    };
    // Apply generator defaults from schema.json file etc
    const combinedOpts = await (0, params_1.combineOptionsForGenerator)(generatorOptions, generatorData.collectionName, generatorData.normalizedGeneratorName, (0, project_graph_1.readProjectsConfigurationFromProjectGraph)(projectGraph), nxJson, generatorData.schema, false, null, (0, node_path_1.relative)(process.cwd(), devkit_exports_1.workspaceRoot), args.verbose);
    const releaseVersionGenerator = generatorData.implementationFactory();
    // We expect all version generator implementations to return a VersionData object, rather than a GeneratorCallback
    const versionDataForProjects = (await releaseVersionGenerator(tree, combinedOpts));
    if (typeof versionDataForProjects === 'function') {
        throw new Error(`The version generator ${generatorData.collectionName}:${generatorData.normalizedGeneratorName} returned a function instead of an expected VersionData object`);
    }
    // Merge the extra version data into the existing
    appendVersionData(versionData, versionDataForProjects);
}
function printAndFlushChanges(tree, isDryRun) {
    const changes = tree.listChanges();
    console.log('');
    // Print the changes
    changes.forEach((f) => {
        if (f.type === 'CREATE') {
            console.error(`${chalk.green('CREATE')} ${f.path}${isDryRun ? chalk.keyword('orange')(' [dry-run]') : ''}`);
            (0, print_changes_1.printDiff)('', f.content?.toString() || '');
        }
        else if (f.type === 'UPDATE') {
            console.error(`${chalk.white('UPDATE')} ${f.path}${isDryRun ? chalk.keyword('orange')(' [dry-run]') : ''}`);
            const currentContentsOnDisk = (0, node_fs_1.readFileSync)((0, devkit_exports_1.joinPathFragments)(tree.root, f.path)).toString();
            (0, print_changes_1.printDiff)(currentContentsOnDisk, f.content?.toString() || '');
        }
        else if (f.type === 'DELETE') {
            throw new Error('Unexpected DELETE change, please report this as an issue');
        }
    });
    if (!isDryRun) {
        (0, tree_1.flushChanges)(devkit_exports_1.workspaceRoot, changes);
    }
}
function extractGeneratorCollectionAndName(description, generatorString) {
    let collectionName;
    let generatorName;
    const parsedGeneratorString = (0, generate_1.parseGeneratorString)(generatorString);
    collectionName = parsedGeneratorString.collection;
    generatorName = parsedGeneratorString.generator;
    if (!collectionName || !generatorName) {
        throw new Error(`Invalid generator string: ${generatorString} used for ${description}. Must be in the format of [collectionName]:[generatorName]`);
    }
    return { collectionName, generatorName };
}
function resolveGeneratorData({ collectionName, generatorName, configGeneratorOptions, projects, }) {
    const { normalizedGeneratorName, schema, implementationFactory } = (0, generator_utils_1.getGeneratorInformation)(collectionName, generatorName, devkit_exports_1.workspaceRoot, projects);
    return {
        collectionName,
        generatorName,
        configGeneratorOptions,
        normalizedGeneratorName,
        schema,
        implementationFactory,
    };
}
