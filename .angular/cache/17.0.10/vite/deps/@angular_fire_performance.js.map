{
  "version": 3,
  "sources": ["../../../../../node_modules/rxfire/performance/index.esm.js", "../../../../../node_modules/@angular/fire/fesm2022/angular-fire-performance.mjs"],
  "sourcesContent": ["import { from, Observable, EMPTY } from 'rxjs';\nimport { tap } from 'rxjs/operators';\n\n/**\n * Lazy loads Firebase Performance monitoring and returns the instance as\n * an observable\n * @param app\n * @returns Observable<FirebasePerformance>\n */\nvar getPerformance$ = function (app) { return from(import('firebase/performance').then(function (module) { return module.getPerformance(app); })); };\n/**\n * Creates an observable that begins a trace with a given id. The trace is ended\n * when the observable unsubscribes. The measurement is also logged as a performance\n * entry.\n * @param traceId\n * @returns Observable<void>\n */\nvar trace$ = function (traceId) {\n    if (typeof window !== 'undefined' && window.performance) {\n        var entries = window.performance.getEntriesByName(traceId, 'measure') || [];\n        var startMarkName_1 = \"_\".concat(traceId, \"Start[\").concat(entries.length, \"]\");\n        var endMarkName_1 = \"_\".concat(traceId, \"End[\").concat(entries.length, \"]\");\n        return new Observable(function (emitter) {\n            window.performance.mark(startMarkName_1);\n            emitter.next();\n            return {\n                unsubscribe: function () {\n                    window.performance.mark(endMarkName_1);\n                    window.performance.measure(traceId, startMarkName_1, endMarkName_1);\n                },\n            };\n        });\n    }\n    else {\n        return EMPTY;\n    }\n};\n/**\n * Creates a function that creates an observable that begins a trace with a given id. The trace is ended\n * when the observable unsubscribes. The measurement is also logged as a performance\n * entry.\n * @param name\n * @returns (source$: Observable<T>) => Observable<T>\n */\nvar trace = function (name) { return function (source$) { return new Observable(function (subscriber) {\n    var traceSubscription = trace$(name).subscribe();\n    return source$.pipe(tap(function () { return traceSubscription.unsubscribe(); }, function () {\n    }, function () { return traceSubscription.unsubscribe(); })).subscribe(subscriber);\n}); }; };\n/**\n * Creates a function that creates an observable that begins a trace with a given name. The trace runs until\n * a condition resolves to true and then the observable unsubscribes and ends the trace.\n * @param name\n * @param test\n * @param options\n * @returns (source$: Observable<T>) => Observable<T>\n */\nvar traceUntil = function (name, test, options) { return function (source$) { return new Observable(function (subscriber) {\n    var traceSubscription = trace$(name).subscribe();\n    return source$.pipe(tap(function (a) { return test(a) && traceSubscription.unsubscribe(); }, function () {\n    }, function () { return options && options.orComplete && traceSubscription.unsubscribe(); })).subscribe(subscriber);\n}); }; };\n/**\n * Creates a function that creates an observable that begins a trace with a given name. The trace runs while\n * a condition resolves to true. Once the condition fails the observable unsubscribes\n * and ends the trace.\n * @param name\n * @param test\n * @param options\n * @returns (source$: Observable<T>) => Observable<T>\n */\nvar traceWhile = function (name, test, options) { return function (source$) { return new Observable(function (subscriber) {\n    var traceSubscription;\n    return source$.pipe(tap(function (a) {\n        if (test(a)) {\n            traceSubscription = traceSubscription || trace$(name).subscribe();\n        }\n        else {\n            if (traceSubscription) {\n                traceSubscription.unsubscribe();\n            }\n            traceSubscription = undefined;\n        }\n    }, function () {\n    }, function () { return options && options.orComplete && traceSubscription && traceSubscription.unsubscribe(); })).subscribe(subscriber);\n}); }; };\n/**\n * Creates a function that creates an observable that begins a trace with a given name. The trace runs until the\n * observable fully completes.\n * @param name\n * @returns (source$: Observable<T>) => Observable<T>\n */\nvar traceUntilComplete = function (name) { return function (source$) { return new Observable(function (subscriber) {\n    var traceSubscription = trace$(name).subscribe();\n    return source$.pipe(tap(function () {\n    }, function () {\n    }, function () { return traceSubscription.unsubscribe(); })).subscribe(subscriber);\n}); }; };\n/**\n * Creates a function that creates an observable that begins a trace with a given name.\n * The trace runs until the first value emits from the provided observable.\n * @param name\n * @returns (source$: Observable<T>) => Observable<T>\n */\nvar traceUntilFirst = function (name) { return function (source$) { return new Observable(function (subscriber) {\n    var traceSubscription = trace$(name).subscribe();\n    return source$.pipe(tap(function () { return traceSubscription.unsubscribe(); }, function () {\n    }, function () {\n    })).subscribe(subscriber);\n}); }; };\n\nexport { getPerformance$, trace, traceUntil, traceUntilComplete, traceUntilFirst, traceWhile };\n\n", "import { ɵgetAllInstancesOf, ɵgetDefaultInstanceOf, VERSION, ɵAngularFireSchedulers, ɵzoneWrap } from '@angular/fire';\nimport { from, timer } from 'rxjs';\nimport { concatMap, distinct } from 'rxjs/operators';\nimport { isPlatformBrowser } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, Optional, PLATFORM_ID, NgModule, NgZone, Injector } from '@angular/core';\nimport { FirebaseApp, FirebaseApps } from '@angular/fire/app';\nimport { registerVersion } from 'firebase/app';\nimport { traceUntil as traceUntil$1, traceWhile as traceWhile$1, traceUntilComplete as traceUntilComplete$1, traceUntilFirst as traceUntilFirst$1 } from 'rxfire/performance';\nimport { getPerformance as getPerformance$1, initializePerformance as initializePerformance$1, trace as trace$1 } from 'firebase/performance';\nexport * from 'firebase/performance';\nclass Performance {\n  constructor(performance) {\n    return performance;\n  }\n}\nconst PERFORMANCE_PROVIDER_NAME = 'performance';\nclass PerformanceInstances {\n  constructor() {\n    return ɵgetAllInstancesOf(PERFORMANCE_PROVIDER_NAME);\n  }\n}\nconst performanceInstance$ = timer(0, 300).pipe(concatMap(() => from(ɵgetAllInstancesOf(PERFORMANCE_PROVIDER_NAME))), distinct());\nconst PROVIDED_PERFORMANCE_INSTANCES = new InjectionToken('angularfire2.performance-instances');\nfunction defaultPerformanceInstanceFactory(provided, defaultApp,\n// eslint-disable-next-line @typescript-eslint/ban-types\nplatform) {\n  if (!isPlatformBrowser(platform)) {\n    return null;\n  }\n  const defaultPerformance = ɵgetDefaultInstanceOf(PERFORMANCE_PROVIDER_NAME, provided, defaultApp);\n  return defaultPerformance && new Performance(defaultPerformance);\n}\nfunction performanceInstanceFactory(fn) {\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  return (zone, platform, injector) => {\n    if (!isPlatformBrowser(platform)) {\n      return null;\n    }\n    const performance = zone.runOutsideAngular(() => fn(injector));\n    return new Performance(performance);\n  };\n}\nconst PERFORMANCE_INSTANCES_PROVIDER = {\n  provide: PerformanceInstances,\n  deps: [[new Optional(), PROVIDED_PERFORMANCE_INSTANCES]]\n};\nconst DEFAULT_PERFORMANCE_INSTANCE_PROVIDER = {\n  provide: Performance,\n  useFactory: defaultPerformanceInstanceFactory,\n  deps: [[new Optional(), PROVIDED_PERFORMANCE_INSTANCES], FirebaseApp, PLATFORM_ID]\n};\nclass PerformanceModule {\n  constructor() {\n    registerVersion('angularfire', VERSION.full, 'perf');\n  }\n  static ɵfac = function PerformanceModule_Factory(t) {\n    return new (t || PerformanceModule)();\n  };\n  static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: PerformanceModule\n  });\n  static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [DEFAULT_PERFORMANCE_INSTANCE_PROVIDER, PERFORMANCE_INSTANCES_PROVIDER]\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(PerformanceModule, [{\n    type: NgModule,\n    args: [{\n      providers: [DEFAULT_PERFORMANCE_INSTANCE_PROVIDER, PERFORMANCE_INSTANCES_PROVIDER]\n    }]\n  }], () => [], null);\n})();\nfunction providePerformance(fn, ...deps) {\n  return {\n    ngModule: PerformanceModule,\n    providers: [{\n      provide: PROVIDED_PERFORMANCE_INSTANCES,\n      useFactory: performanceInstanceFactory(fn),\n      multi: true,\n      deps: [NgZone, PLATFORM_ID, Injector, ɵAngularFireSchedulers, FirebaseApps, ...deps]\n    }]\n  };\n}\n\n// DO NOT MODIFY, this file is autogenerated by tools/build.ts\nconst traceUntil = ɵzoneWrap(traceUntil$1, true);\nconst traceWhile = ɵzoneWrap(traceWhile$1, true);\nconst traceUntilComplete = ɵzoneWrap(traceUntilComplete$1, true);\nconst traceUntilFirst = ɵzoneWrap(traceUntilFirst$1, true);\n\n// DO NOT MODIFY, this file is autogenerated by tools/build.ts\nconst getPerformance = ɵzoneWrap(getPerformance$1, true);\nconst initializePerformance = ɵzoneWrap(initializePerformance$1, true);\nconst trace = ɵzoneWrap(trace$1, true);\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { Performance, PerformanceInstances, PerformanceModule, getPerformance, initializePerformance, performanceInstance$, providePerformance, trace, traceUntil, traceUntilComplete, traceUntilFirst, traceWhile };\n"],
  "mappings": "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",
  "names": ["traceUntil", "traceWhile", "traceUntilComplete", "traceUntilFirst", "getPerformance", "initializePerformance", "trace"]
}
